/*
  repacky - my toy RPC code
  Copyright (C) 2024 Kamil Ignacak

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/




#define _POSIX_C_SOURCE 200809L
#define _DEFAULT_SOURCE




#include <ctype.h>
#include <errno.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rpc_services.h" /* This one is auto-generated by rpcgen. */




extern CLIENT * g_client;




typedef struct test_params_t {
	int usleep_duration;
	int thread_idx;
} test_params_t;


static char g_input[TEST_THREADS_COUNT][TEST_DATA_SIZE + 1] = {
	"0123456789abcdef0123456789abcdef",
	"caffeeBEEFcaffeeBEEFcaffeeBEEFca",
	"f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0"
};


static char g_expected_readback[TEST_THREADS_COUNT][TEST_DATA_SIZE + 1] = {
	"0123456789abcdef0123456789abcdef",
	"caffeeBEEFcaffeeBEEFcaffeeBEEFca",
	"f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0"
};

static int g_loop_iters[TEST_THREADS_COUNT] = { 0 };

static bool g_test_failure;




static void * transport_test_thread(void * arg)
{
	test_params_t * params = (test_params_t *) arg;
	const int idx = params->thread_idx;

	const int n_loops = 100000;
	int percent = 0;
	int percent_i = 0;

	for (g_loop_iters[idx] = 0; g_loop_iters[idx]  < n_loops; g_loop_iters[idx] ++) {
		//fprintf(stderr, "Thread #%d\n", params->thread_idx); /* Debug. */
		if (0 == idx) {
			/* Poor man's progress indicator. Useful if you need
			   to know where the tests are when n_loops is very
			   high. Displaying progress of only first thread is
			   enough. */
			const int n_iterations_per_percent = n_loops / 100;
			if (g_loop_iters[idx]  == percent_i) {
				percent_i += n_iterations_per_percent;
				fprintf(stdout, "\r");
				fprintf(stdout, "%3d%% (iters: %d, %d, %d)", percent, g_loop_iters[0], g_loop_iters[1], g_loop_iters[2]);
				fflush(stdout);
				percent++;
			}
		}

		/* This is a stupid attempt to make the threads iterate at
		   the same speed. For some reason thread 0th is considerably
		   slower than the other two. */
		if (params->usleep_duration > 0) {
			usleep(params->usleep_duration);
		}

		int dummy = 0;
		const enum clnt_stat rpcstatus1 = fn_transport_test_set_1(g_input[idx], idx, &dummy, g_client);
		if (RPC_SUCCESS != rpcstatus1) {
			fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus1);
			g_test_failure = true;
			return NULL;
		}

		const enum clnt_stat rpcstatus2 = fn_transport_test_get_1(idx, g_expected_readback[idx], g_client);
		if (RPC_SUCCESS != rpcstatus2) {
			fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus2);
			g_test_failure = true;
			return NULL;
		}

		if (0 != memcmp(g_expected_readback[idx], g_input[idx], TEST_DATA_SIZE)) {
			fprintf(stderr, "[EE] RPC client: test data mismatch in thread %d\n", idx);
			fprintf(stderr, "[EE] RPC client: [%s] != [%s]\n", g_expected_readback[idx], g_input[idx]);
			g_test_failure = true;
			return NULL;
		}
	}

	fprintf(stdout, "[II] RPC client: test thread %d/%d completes\n", idx + 1, TEST_THREADS_COUNT);

	return NULL;
}




int transport_test(void)
{
	g_test_failure = false; /* Clear state of previous test. */

	const int usleep_duration = 1;
	pthread_t ids[TEST_THREADS_COUNT];
	pthread_attr_t attrs[TEST_THREADS_COUNT];
	test_params_t params[TEST_THREADS_COUNT] = {
		{ .thread_idx = 0, .usleep_duration = 1 * usleep_duration},
		{ .thread_idx = 1, .usleep_duration = 2 * usleep_duration },
		{ .thread_idx = 2, .usleep_duration = 3 * usleep_duration },
	};

	for (int idx = 0; idx < TEST_THREADS_COUNT; idx++) {
		pthread_attr_init(&attrs[idx]);
		pthread_create(&ids[idx], &attrs[idx], transport_test_thread, &params[idx]);
	}

	for (int idx = 0; idx < TEST_THREADS_COUNT; idx++) {
		pthread_join(ids[idx], NULL);
	}


	if (g_test_failure) {
		fprintf(stderr, "[EE] RPC client: test failure flag is set\n");
		return -1;
	}

	return 0;
}

