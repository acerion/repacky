/*
  repacky - my toy RPC code
  Copyright (C) 2024 Kamil Ignacak

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/




#define _POSIX_C_SOURCE 200809L




#include <ctype.h>
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "rpc_services.h" /* This one is auto-generated by rpcgen. */

#include "functions.h"




extern CLIENT * g_client;




int my_gettimeofday(struct timeval * tv)
{
	my_timeval_t val = { 0 };
	const enum clnt_stat rpcstatus = fn_gettimeofday_1(&val, g_client);
	if (RPC_SUCCESS != rpcstatus) {
		fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus);
		return -1;
	}

	tv->tv_sec = val.tv_sec;
	tv->tv_usec = val.tv_usec;
	return 0;
}




int my_add3(int a, int b, int c, int * result)
{
	const enum clnt_stat rpcstatus = fn_add3_1(a, b, c, result, g_client);
	if (RPC_SUCCESS != rpcstatus) {
		fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus);
		return -1;
	}

	return 0;
}




int sm_next(void)
{
	sm_state_t state;
	const enum clnt_stat rpcstatus = fn_sm_next_1(&state, g_client);
	if (RPC_SUCCESS != rpcstatus) {
		fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus);
		return -1;
	}

	char label_arr[SM_STATE_LABEL_SIZE] = { 0 };
	sm_get_current_label(label_arr);

	fprintf(stdout, "[II] RPC client: state machine has changed state to [%d]/[%s] at timestamp [%lu]\n",
		state.sm_state, label_arr, state.change_timestamp);
	return 0;
}




int sm_prev(void)
{
	sm_state_t state;
	const enum clnt_stat rpcstatus = fn_sm_prev_1(&state, g_client);
	if (RPC_SUCCESS != rpcstatus) {
		fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus);
		return -1;
	}

	char label_arr[SM_STATE_LABEL_SIZE] = { 0 };
	sm_get_current_label(label_arr);

	fprintf(stdout, "[II] RPC client: state machine has changed state to [%d]/[%s] at timestamp [%lu]\n",
		state.sm_state, label_arr, state.change_timestamp);

	return 0;
}



int sm_set_label(const char * label, int idx)
{
	char old_label[SM_STATE_LABEL_SIZE] = { 0 };
	char new_label[SM_STATE_LABEL_SIZE] = { 0 };
	snprintf(new_label, sizeof (new_label), "%s", label);

	const enum clnt_stat rpcstatus = fn_sm_set_label_1(new_label, idx, old_label, g_client);
	if (RPC_SUCCESS != rpcstatus) {
		fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus);
		return -1;
	}

	fprintf(stdout, "[II] RPC client: changed label #%d: [%s] -> [%s]\n", idx, old_label, new_label);
	return 0;
}




int sm_get_current_label(char * label_arr)
{
	const enum clnt_stat rpcstatus = fn_sm_get_current_label_1(label_arr, g_client);
	if (RPC_SUCCESS != rpcstatus) {
		fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus);
		return -1;
	}

	return 0;
}




int sm_get_all_info(sm_all_info_t * info)
{
	const enum clnt_stat rpcstatus = fn_sm_get_all_info_1(info, g_client);
	if (RPC_SUCCESS != rpcstatus) {
		fprintf(stderr, "[EE] RPC client: %s:%d, rpcstatus = %d\n", __func__, __LINE__, rpcstatus);
		return -1;
	}

	return 0;

}


