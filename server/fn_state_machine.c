/*
  repacky - my toy RPC code
  Copyright (C) 2024 Kamil Ignacak

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/




#include <rpc/rpc.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "rpc_services.h" /* This file is generated by rpcgen. */




#define SM_STATE_LABELS_COUNT  (1 + 7)




static sm_state_t g_state_machine;
static char g_state_labels[SM_STATE_LABELS_COUNT][SM_STATE_LABEL_SIZE];





__attribute__ ((constructor)) static int init_labels(void)
{
	const char * labels[] = {
		"initial",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday",
		"Sunday",
	};

	//fprintf(stdout, "[DD] RPC server: ctor called\n");

	for (int i = 0; i < SM_STATE_LABELS_COUNT; i++) {
		snprintf(g_state_labels[i], sizeof (g_state_labels[i]), "%s", labels[i]);
	}

	return 0;
}



bool_t fn_sm_next_1_svc(sm_state_t * sm, __attribute((unused)) struct svc_req * req)
{
	const time_t timestamp = time(NULL);
	const sm_state_e current = g_state_machine.sm_state;

	sm_state_e next = sm_state_init;
	if (current == sm_state_sunday) {
		next = sm_state_monday;
	} else {
		next = current + 1;
	}

	fprintf(stdout, "[II] RPC server: moving to next state: [%s] -> [%s] at timestamp %lu\n",
		g_state_labels[current], g_state_labels[next], timestamp);

	g_state_machine.sm_state = next;
	g_state_machine.change_timestamp = (u_long) timestamp;

	sm->sm_state = g_state_machine.sm_state;
	sm->change_timestamp = g_state_machine.change_timestamp;

	return TRUE;
}




bool_t fn_sm_prev_1_svc(sm_state_t * sm, __attribute((unused)) struct svc_req * req)
{
	const time_t timestamp = time(NULL);
	const sm_state_e current = g_state_machine.sm_state;

	sm_state_e prev = sm_state_init;
	if (current == sm_state_init || current == sm_state_monday) {
		prev = sm_state_sunday;
	} else {
		prev = current - 1;
	}

	fprintf(stdout, "[II] RPC server: moving to prev state: [%s] -> [%s] at timestamp %lu\n",
		g_state_labels[current], g_state_labels[prev], timestamp);

	g_state_machine.sm_state = prev;
	g_state_machine.change_timestamp = (u_long) timestamp;

	sm->sm_state = g_state_machine.sm_state;
	sm->change_timestamp = g_state_machine.change_timestamp;

	return TRUE;
}




bool_t fn_sm_set_label_1_svc(char * new_label_ptr, int idx, char * previous_label_arr, __attribute((unused)) struct svc_req * req)
{
	fprintf(stdout, "[II] RPC server: replacing label #%d: [%s] -> [%s]\n",
		idx, g_state_labels[idx], new_label_ptr);

	snprintf(previous_label_arr, SM_STATE_LABEL_SIZE, "%s", g_state_labels[idx]);
	snprintf(g_state_labels[idx], SM_STATE_LABEL_SIZE, "%s", new_label_ptr);

	return TRUE;
}




bool_t fn_sm_get_current_label_1_svc(char * label_arr, __attribute((unused)) struct svc_req * req)
{
	const sm_state_e current = g_state_machine.sm_state;

	snprintf(label_arr, SM_STATE_LABEL_SIZE, "%s", g_state_labels[current]);
	fprintf(stdout, "[II] RPC server: current state's label is [%s]\n", label_arr);
	return TRUE;
}




bool_t fn_sm_get_all_info_1_svc(sm_all_info_t * info, __attribute((unused)) struct svc_req * req)
{
	info->state.sm_state = g_state_machine.sm_state;
	info->state.change_timestamp = g_state_machine.change_timestamp;
	snprintf(info->label_arr, sizeof (info->label_arr), "%s", g_state_labels[info->state.sm_state]);

	fprintf(stdout, "[II] RPC server: all info: state = [%d], timestamp = [%lu], label = [%s]\n",
		info->state.sm_state,
		info->state.change_timestamp,
		info->label_arr);
	return TRUE;
}

